package com.flying.xiaomi;

/**
 * 类加载步骤
 * Java中的类加载大体分为四类：启动类加载器（Bootstrap ClassLoader）扩展类加载器（Extension ClassLoader）应用程序类加载器（Application ClassLoader）用户自定义类加载器（User ClassLoader）
 * 启动类加载器：
 * 负责加载JDK目录中\lib文件夹中的类，或者被-Xbootclasspath参数指定的路径下的可识别类。整个Java系统中很多基本组件都是有启动类加载器加载的，就连扩展类加载器和应用程序类加载器都是通过它加载的。在一个Java程序运行时，首先启动JVM，之后马上就诞生了启动类加载器，然后启动类加载器加载剩下两个系统加载器，之后这两个加载器再加载他们应该加载的类。
 * 扩展类加载器：
 * 负责加载JDK目录中\lib\ext文件夹中的类，或者被java.ext.dirs系统变量所指定的路径中的类库。这个类加载器的作用是用来与启动类加载器合作加载系统组件的。
 * 应用程序类加载器：
 * 负责加载ClassPath路径下的类，可以通过getSystemClassLoader()获取。如果没有自己定义类加载，我们编写的Java类都将被这个类加载器加载。是程序中的默认类加载。
 * 用户自定义类加载器：
 * 用户自己编写的类加载器，可以通过覆盖findClass()方法去进行加载类。
 *
 * Java虚拟机中类加载的过程
 * 当程序要使用某个类时，如果该类还未被加载到内存中，则系统会通过加载，连接，初始化三步来实现这个类进行初始化。
 * 1.    加载
 * 加载，是指Java虚拟机查找字节流（查找.class文件），并且根据字节流创建java.lang.Class对象的过程。这个过程，将类的.class文件中的二进制数据读入内存，放在运行时区域的方法区内。然后在堆中创建java.lang.Class对象，用来封装类在方法区的数据结构。
 * 类加载阶段：
 * （1）Java虚拟机将.class文件读入内存，并为之创建一个Class对象。
 * （2）任何类被使用时系统都会为其创建一个且仅有一个Class对象。
 * （3）这个Class对象描述了这个类创建出来的对象的所有信息，比如有哪些构造方法，都有哪些成员方法，都有哪些成员变量等。
 * 2.    链接
 * 链接包括验证、准备以及解析三个阶段。
 * （1）验证阶段。主要的目的是确保被加载的类（.class文件的字节流）满足Java虚拟机规范，不会造成安全错误。
 * （2）准备阶段。负责为类的静态成员分配内存，并设置默认初始值。
 * （3）解析阶段。将类的二进制数据中的符号引用替换为直接引用。
 * 说明：
 * 符号引用。即一个字符串，但是这个字符串给出了一些能够唯一性识别一个方法，一个变量，一个类的相关信息。
 * 直接引用。可以理解为一个内存地址，或者一个偏移量。比如类方法，类变量的直接引用是指向方法区的指针；而实例方法，实例变量的直接引用则是从实例的头指针开始算起到这个实例变量位置的偏移量。
 * 举个例子来说，现在调用方法hello()，这个方法的地址是0xaabbccdd，那么hello就是符号引用，0xaabbccdd就是直接引用。
 * 在解析阶段，虚拟机会把所有的类名，方法名，字段名这些符号引用替换为具体的内存地址或偏移量，也就是直接引用。
 * 3.    初始化
 * 初始化，则是为标记为常量值的字段赋值的过程。换句话说，只对static修饰的变量或语句块进行初始化。
 * 如果初始化一个类的时候，其父类尚未初始化，则优先初始化其父类。
 * 如果同时包含多个静态变量和静态代码块，则按照自上而下的顺序依次执行。
 * 4.    小结
 * 类加载过程只是一个类生命周期的一部分，在其前，有编译的过程，只有对源代码编译之后，才能获得能够被虚拟机加载的字节码文件；在其后还有具体的类使用过程，当使用完成之后，还会在方法区垃圾回收的过程中进行卸载（垃圾回收）。
 * 5.    附录
 * 常见问题：在自己的项目里新建一个java.lang包，里面新建了一个String类，能代替系统String吗？
 * 不能，因为根据类加载的双亲委派机制，会将请求转发给父类加载器，父类加载器发现冲突了String就不会加载了。
 */
public class Q2 {
}
