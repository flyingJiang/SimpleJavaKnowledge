package com.flying.redis.ditributedLock;

/**
 * https://www.cnblogs.com/mengchunchen/p/9647756.html
 * https://blog.csdn.net/jiayoubing/article/details/105296841
 *
 *
 * Redis实现分布式锁
 * 　　1.根据lockKey区进行setnx（set not exist，如果key值为空，则正常设置，返回1，否则不会进行设置并返回0）操作，如果设置成功，表示已经获得锁，否则并没有获取锁。
 * <p>
 * 　　2.如果没有获得锁，去Redis上拿到该key对应的值，在该key上我们存储一个时间戳（用毫秒表示，t1），为了避免死锁以及其他客户端占用该锁超过一定时间（5秒），
 * 使用该客户端当前时间戳，与存储的时间戳作比较。
 * <p>
 * 　　3.如果没有超过该key的使用时限，返回false，表示其他人正在占用该key，不能强制使用；如果已经超过时限，那我们就可以进行解锁，使用我们的时间戳来代替该字段的值。
 * <p>
 * 　　4.但是如果在setnx失败后，get该值却无法拿到该字段时，说明操作之前该锁已经被释放，这个时候，最好的办法就是重新执行一遍setnx方法来获取其值以获得该锁。
 * <p>
 * 　　释放锁：删除redis中key
 */
public class RedisLock {
}

/**
 * Zookeeper实现分布式锁
 * 基于临时顺序节点：
 * <p>
 * 　　1.客户端调用create()方法创建名为“locknode/guid-lock-”的节点，需要注意的是，这里节点的创建类型需要设置为EPHEMERAL_SEQUENTIAL。
 * <p>
 * 　　2.客户端调用getChildren(“locknode”)方法来获取所有已经创建的子节点。
 * <p>
 * 　　3.客户端获取到所有子节点path之后，如果发现自己在步骤1中创建的节点是所有节点中序号最小的，那么就认为这个客户端获得了锁。
 * <p>
 * 　　4.如果创建的节点不是所有节点中序号最小的，那么则监视比自己创建节点的序列号小的最大的节点，进入等待。直到下次监视的子节点变更的时候，再进行子节点的获取，判断是否获取锁。
 * <p>
 * 　　释放锁的过程相对比较简单，就是删除自己创建的那个子节点即可
 */
class ZookeeperLock {

}
/***
 * 另一个版本：
 * 　　zk分布式锁，就是某个节点尝试创建临时znode，此时创建成功了就获取了这个锁；这个时候别的客户端来创建锁会失败，只能注册个监听器监听这个锁。
 * 　　释放锁就是删除这个znode，一旦释放掉就会通知客户端，然后有一个等待着的客户端就可以再次重新加锁。
 *
 * 　　redis分布式锁，其实需要自己不断去尝试获取锁，比较消耗性能
 * 　　zk分布式锁，获取不到锁，注册个监听器即可，不需要不断主动尝试获取锁，性能开销较小
 * 　　另外一点就是，如果是redis获取锁的那个客户端bug了或者挂了，那么只能等待超时时间之后才能释放锁；
 * 而zk的话，因为创建的是临时znode，只要客户端挂了，znode就没了，此时就自动释放锁
 */

/****
 * https://www.cnblogs.com/rgcLOVEyaya/p/RGC_LOVE_YAYA_1003days.html
 * 1.TTL时长 要大于正常业务执行的时间+获取所有redis服务消耗时间+时钟漂移
 *
 * 2.获取redis所有服务消耗时间要 远小于TTL时间，并且获取成功的锁个数要 在总数的一般以上:N/2+1
 *
 * 3.尝试获取每个redis实例锁时的时间要 远小于TTL时间
 *
 * 4.尝试获取所有锁失败后 重新尝试一定要有一定次数限制
 *
 * 5.在redis崩溃后（无论一个还是所有），要延迟TTL时间重启redis
 *
 * 6.在实现多redis节点时要结合单节点分布式锁算法 共同实现
 *
 */

