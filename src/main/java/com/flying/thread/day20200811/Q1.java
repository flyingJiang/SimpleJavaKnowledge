package com.flying.thread.day20200811;
/**
 * 第一：无锁、偏向锁、轻量级锁、重量级锁有什么差别？
 * https://blog.csdn.net/bingxuesiyang/article/details/89332989
 *
 * java中每个对象都可作为锁，锁有四种级别，按照量级从轻到重分为：无锁、偏向锁、轻量级锁、重量级锁。并且锁只能升级不能降级。
 *
 * 在讲这三个锁之前，我先给大家讲清楚自旋和对象头的概念。
 *
 * 自旋
 * 现在假设有这么一个场景：有两个线程A,B在竞争一个锁，假设A拿到了，这个时候B被挂起阻塞，一直等待A释放了锁B才得到使用权。在操作系统中阻塞和唤醒是一个耗时操作，如果A在很短的时间内就释放了锁，当这个时间与阻塞唤醒比较起来更短的时候，我们将B挂起，其实不是一个最优的选择。
 * 自旋是指某线程需要获取锁，但该锁已经被其他线程占用时，该线程不会被挂起，而是在不断的消耗CPU的时间，不停的试图获取锁。虽然CPU的时间被消耗了，但是比线程下文切换时间要少。这个时候使用自旋是划算的。
 * 如果是单核处理器，一般建议不要使用自旋锁。因为只有单个处理器，自旋占用的时间片使得代价很高。
 * 而偏向锁、轻量锁、重量锁也是一个锁围绕着如何使得程序运行的更加“划算”而进行改变的。
 *
 * 对象头
 * HotSpot虚拟机中，对象在内存中存储的布局可以分为三块区域：对象头（Header）、实例数据（Instance Data）和对齐填充（Padding）。
 *
 * HotSpot虚拟机的对象头(Object Header)包括两部分信息，第一部分用于存储对象自身的运行时数据， 如哈希码（HashCode）、GC分代年龄、锁状态标志、线程持有的锁、偏向线程ID、偏向时间戳等等，这部分数据的长度在32位和64位的虚拟机（暂 不考虑开启压缩指针的场景）中分别为32个和64个Bits，官方称它为“Mark Word”。
 * 在32位的HotSpot虚拟机 中对象未被锁定的状态下，Mark Word的32个Bits空间中的25Bits用于存储对象哈希码（HashCode），4Bits用于存储对象分代年龄，2Bits用于存储锁标志 位，1Bit固定为0，在其他状态（轻量级锁定、重量级锁定、GC标记、可偏向）下对象的存储内容如下表所示。
 *
 *
 * 偏向锁
 * 引入偏向锁是为了在无多线程竞争的情况下尽量减少不必要的轻量级锁执行路径，因为轻量级锁的获取及释放依赖多次CAS原子指令，而偏向锁只需要在置换ThreadID的时候依赖一次CAS原子指令。
 * 当只有一个线程去竞争锁的时候，我们不需要阻塞，也不需要自旋，因为只有一个线程在竞争，我们只要去判断该偏向锁中的ThreadID是否为当前线程即可。如果是就执行同步代码，不是就尝试使用CAS修改ThreadID，修改成功执行同步代码，不成功就将偏向锁升级成轻量锁。
 *
 * 轻量锁
 * 获取轻量锁的过程与偏向锁不同，竞争锁的线程首先需要拷贝对象头中的Mark Word到帧栈的锁记录中。拷贝成功后使用CAS操作尝试将对象的Mark Word更新为指向当前线程的指针。如果这个更新动作成功了，那么这个线程就拥有了该对象的锁。如果更新失败，那么意味着有多个线程在竞争。
 * 当竞争线程尝试占用轻量级锁失败多次之后（使用自旋）轻量级锁就会膨胀为重量级锁，重量级线程指针指向竞争线程，竞争线程也会阻塞，等待轻量级线程释放锁后唤醒他。
 *
 * 重量锁
 * 重量级锁的加锁、解锁过程和轻量级锁差不多，区别是：竞争失败后，线程阻塞，释放锁后，唤醒阻塞的线程，不使用自旋锁，不会那么消耗CPU，所以重量级锁适合用在同步块执行时间长的情况下。
 *
 *
 *
 *
 */
public class Q1 {
}
