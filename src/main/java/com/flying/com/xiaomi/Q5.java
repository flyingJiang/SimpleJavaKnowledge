package com.flying.com.xiaomi;

/**
 * 数据库索引的高度，为什么是这么高？
 * 在InnoDB里，每个页默认16KB，假设索引的是8B的long型数据，每个key后有个页号4B，还有6B的其他数据（参考《MySQL技术内幕：InnoDB存储引擎》P193的页面数据），
 * 那么每个页的扇出系数为16KB/(8B+4B+6B)≈1000，即每个页可以索引1000个key。在高度h=3时，s=1000^3=10亿！！
 * 也就是说，InnoDB通过三次索引页的I/O，即可索引10亿的key。
 * 通常来说，索引树的高度在2~4。当然，这也跟要索引字段的数据类型有关，如果是int或short，索引效率更好，而如果是varchar(100)，
 * 那扇出系数就低了，索引效率自然要低些。所以我们在索引字段时，字段的类型越简单效率越好。
 *
 * 表A有字段id,a,b,c,d。id是主键，a,b,c是联合索引
 * select c from A where a=1 and b=2
 * select d from A where a=1 and b=2
 * select d from A where b=2 and c=3
 *
 * 说到辅助索引，我们还可以延伸出另一种特别的索引，就是覆盖索引。
 * 上面说了，聚簇索引中访问数据要经过二次查找，就是先找到辅助键的叶子结点，得到主键对应的结点后再用主键索引查询数据，这样还是比较慢的，其实，如果我们所需的字段第一次查找就能获取到的话，就不用再二次查找主键了，也就是不用“回表”。
 * 就还是上面那张表有三个字段id，name，company的表来说，我给name加了索引，在查询数据的时候，我就这么写语句：
 * select name from user where name like '张%';
 * 因为我们的语句走了索引，并且返回的字段在叶子结点都存在，查询的时候就不会回表了，多好啊~~
 * 所以，如果所需的字段刚好是索引列的话，尽量用这种查询方式，不要用select *这种语句。
 *
 * https://www.cnblogs.com/aspirant/p/9214485.html
 *  二 磁盘IO与预读 *
 * 考虑到磁盘IO是非常高昂的操作，计算机操作系统做了一些优化，当一次IO时，不光把当前磁盘地址的数据，而是把相邻的数据也都读取到内存缓冲区内，
 * 因为局部预读性原理告诉我们，当计算机访问一个地址的数据的时候，与其相邻的数据也会很快被访问到。每一次IO读取的数据我们称之为一页(page)。
 * 具体一页有多大数据跟操作系统有关，一般为4k或8k，也就是我们读取一页内的数据时候，实际上才发生了一次IO，这个理论对于索引的数据结构设计非常有帮助。
 */
public class Q5 {
}
