package com.flying.com.xiaomi.q6;

/**
 *
 * synchronized 如何实现锁定一个对象
 * 实现原理： JVM 是通过进入、退出 对象监视器(Monitor) 来实现对方法、同步块的同步的，而对象监视器的本质依赖于底层操作系统的 互斥锁(Mutex Lock) 实现。
 * 具体实现是在编译之后在同步方法调用前加入一个monitor.enter指令，在退出方法和异常处插入monitor.exit的指令。
 * 对于没有获取到锁的线程将会阻塞到方法入口处，直到获取锁的线程monitor.exit之后才能尝试继续获取锁。
 *
 * A. 无论synchronized关键字加在方法上还是对象上，
 *  如果它作用的对象是非静态的，则它取得的锁是对象；
 *  如果synchronized作用的对象是一个静态方法或一个类，则它取得的锁是对类，该类所有的对象同一把锁。
 * B. 每个对象只有一个锁（lock）与之相关联，谁拿到这个锁谁就可以运行它所控制的那段代码。
 * C. 实现同步是要很大的系统开销作为代价的，甚至可能造成死锁，所以尽量避免无谓的同步控制。
 *
 *
 * 就我理解的而言，被volatile修饰的共享变量，就具有了以下两点特性：
 * 1 . 保证了不同线程对该变量操作的内存可见性;
 * 2 . 禁止指令重排序
 *
 volatile 如何实现的
 如果把加入volatile关键字的代码和未加入volatile关键字的代码都生成汇编代码，会发现加入volatile关键字的代码会多出一个lock前缀指令。
 lock前缀指令实际相当于一个内存屏障，内存屏障提供了以下功能：
 1 . 重排序时不能把后面的指令重排序到内存屏障之前的位置
 2 . 使得本CPU的Cache写入内存
 3 . 写入动作也会引起别的CPU或者别的内核无效化其Cache，相当于让新写入的值对别的线程可见。

 当写一个volatile变量时，JMM会把该线程对应的本地内存中的共享变量刷新到主内存
 当读一个volatile变量时，JMM会把该线程对应的本地内存置为无效，线程接下来将从主内存中读取共享变量。

 三.volatile关键字的实现原理
 在java代码编译成字节码时会在volatile修饰的共享变量进行写操作的时候会多出Lock前缀的指令。
 我们知道为了提高处理速度，CPU不直接和内存进行通信，而是先将系统内存的数据读到内部缓存（L1，L2或其他）后再进行操作，
 但操作完不知道何时会写回内存。如果对声明了volatile的变量进行写操作，JVM就会向CPU发送一条Lock前缀的指令，
 将这个变量所在缓存行的数据写回到系统内存。但是，就算写回到内存，如果其他处理器缓存的值还是旧的，再执行计算操作就会有问题。
 所以，在多处理器下，为了保证各个CPU的缓存是一致的，就会实现缓存一致性协议，每个CPU通过嗅探在总线上传播的数据来检查自己缓存的值是不是过期了，
 当处理器发现自己缓存行对应的内存地址被修改，就会将当前CPU的缓存行设置成无效状态，当CPU对这个数据进行修改操作的时候，会重新从系统内存中把数据读到处理器缓存里
 Lock前缀的指令会引起CPU缓存写回内存；
 一个CPU的缓存回写到内存会导致其他处理器的缓存失效；
 当CPU发现本地缓存失效后，就会从内存中重读该变量数据，即可以获取当前最新值。
 这样针对volatile变量通过这样的机制就使得每个线程都能获得该变量的最新值

 一.happens-before原则
 同一个线程中的，前面的操作 happens-before 后续的操作。（即单线程内按代码顺序执行。但是，在不影响在单线程环境执行结果的前提下，编译器和处理器可以进行重排序，这是合法的。
 换句话说，这一是规则无法保证编译重排和指令重排）。

 Volatile关键字主要用于保证内存可见性和顺序性：
 1.volatile修饰的变量可以保证一个线程对该变量的写happens-before 一个线程对该变量的读
 2.Volatile可以用来修饰long和double类型的变量使其以原子方式执行
 3.Volatile在双重检查加锁的单例模式中的应用，可以防止重排序
 *
 */
public class Q6 {
    volatile int n = 10;
    synchronized void a(){}
}
