package com.flying.com.xiaomi;

/**
 * 服务之间的接口调用步骤
 *
 * 类加载步骤
 * Java中的类加载大体分为四类：启动类加载器（Bootstrap ClassLoader）扩展类加载器（Extension ClassLoader）应用程序类加载器（Application ClassLoader）用户自定义类加载器（User ClassLoader）
 * 启动类加载器：
 * 负责加载JDK目录中\lib文件夹中的类，或者被-Xbootclasspath参数指定的路径下的可识别类。整个Java系统中很多基本组件都是有启动类加载器加载的，就连扩展类加载器和应用程序类加载器都是通过它加载的。在一个Java程序运行时，首先启动JVM，之后马上就诞生了启动类加载器，然后启动类加载器加载剩下两个系统加载器，之后这两个加载器再加载他们应该加载的类。
 * 扩展类加载器：
 * 负责加载JDK目录中\lib\ext文件夹中的类，或者被java.ext.dirs系统变量所指定的路径中的类库。这个类加载器的作用是用来与启动类加载器合作加载系统组件的。
 * 应用程序类加载器：
 * 负责加载ClassPath路径下的类，可以通过getSystemClassLoader()获取。如果没有自己定义类加载，我们编写的Java类都将被这个类加载器加载。是程序中的默认类加载。
 * 用户自定义类加载器：
 * 用户自己编写的类加载器，可以通过覆盖findClass()方法去进行加载类。
 *
 * Java虚拟机中类加载的过程
 * 当程序要使用某个类时，如果该类还未被加载到内存中，则系统会通过加载，连接，初始化三步来实现这个类进行初始化。
 * 1.    加载
 * 加载，是指Java虚拟机查找字节流（查找.class文件），并且根据字节流创建java.lang.Class对象的过程。这个过程，将类的.class文件中的二进制数据读入内存，放在运行时区域的方法区内。然后在堆中创建java.lang.Class对象，用来封装类在方法区的数据结构。
 * 类加载阶段：
 * （1）Java虚拟机将.class文件读入内存，并为之创建一个Class对象。
 * （2）任何类被使用时系统都会为其创建一个且仅有一个Class对象。
 * （3）这个Class对象描述了这个类创建出来的对象的所有信息，比如有哪些构造方法，都有哪些成员方法，都有哪些成员变量等。
 * 2.    链接
 * 链接包括验证、准备以及解析三个阶段。
 * （1）验证阶段。主要的目的是确保被加载的类（.class文件的字节流）满足Java虚拟机规范，不会造成安全错误。
 * （2）准备阶段。负责为类的静态成员分配内存，并设置默认初始值。
 * （3）解析阶段。将类的二进制数据中的符号引用替换为直接引用。
 * 说明：
 * 符号引用。即一个字符串，但是这个字符串给出了一些能够唯一性识别一个方法，一个变量，一个类的相关信息。
 * 直接引用。可以理解为一个内存地址，或者一个偏移量。比如类方法，类变量的直接引用是指向方法区的指针；而实例方法，实例变量的直接引用则是从实例的头指针开始算起到这个实例变量位置的偏移量。
 * 举个例子来说，现在调用方法hello()，这个方法的地址是0xaabbccdd，那么hello就是符号引用，0xaabbccdd就是直接引用。
 * 在解析阶段，虚拟机会把所有的类名，方法名，字段名这些符号引用替换为具体的内存地址或偏移量，也就是直接引用。
 * 3.    初始化
 * 初始化，则是为标记为常量值的字段赋值的过程。换句话说，只对static修饰的变量或语句块进行初始化。
 * 如果初始化一个类的时候，其父类尚未初始化，则优先初始化其父类。
 * 如果同时包含多个静态变量和静态代码块，则按照自上而下的顺序依次执行。
 * 4.    小结
 * 类加载过程只是一个类生命周期的一部分，在其前，有编译的过程，只有对源代码编译之后，才能获得能够被虚拟机加载的字节码文件；在其后还有具体的类使用过程，当使用完成之后，还会在方法区垃圾回收的过程中进行卸载（垃圾回收）。
 * 5.    附录
 * 常见问题：在自己的项目里新建一个java.lang包，里面新建了一个String类，能代替系统String吗？
 * 不能，因为根据类加载的双亲委派机制，会将请求转发给父类加载器，父类加载器发现冲突了String就不会加载了。
 *
 * new一个对象，内存是如何分配的[https://blog.csdn.net/qq_32379477/article/details/90239891]
 * 1，首先到常量池中找类的带路径全名，然后检查对应的字节码是否已被加载，解析，验证，初始化，如果没有先执行类加载过程(class.forname())。
 * 2，类加载过程完成后，虚拟机会为对象分配内存。分配内存有两种方式，根据使用的垃圾收集器的不同使用不同的分配机制。
 * （1）指针碰撞，当虚拟机使用复制算法或标记整理算法实现的垃圾收集器时，内存区域都是规整的，这时候使用指针碰撞分配内存，用过的内存放在一边，空闲的内存在另一边，中间用一个指针作为分界点，当需要为新对象分配内存时只需把指针向空闲的一边移动一段与对象大小相等的距离。
 * （2）空闲列表，当虚拟机使用标记清除算法实现的垃圾收集器时，内存都是碎片化的，那虚拟机就要记录哪块内存是可用的，当需要分配内存时，找一块足够大的内存空间给对象实例，并更新记录。
 * 3，设置对象头信息，如所属类，元数据信息，哈希码，gc分代年龄，等等。
 * 4，调用对象的init()方法,根据传入的属性值给对象属性赋值。
 * 5，在线程栈中新建对象引用，并指向堆中刚刚新建的对象实例。
 *
 * 4.对象初始化，顺序：
 * (1) 父类静态对象，静态代码块
 * (2)子类静态对象，静态代码块
 * (3)父类非静态对象，非静态代码块
 * (4)父类构造函数
 * (5)子类非静态对象，非静态代码块
 * (6)子类构造函数
 * [https://blog.csdn.net/qq_33824312/article/details/62858138?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.compare&depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.compare]
 * SubClass sub = new SubClass();
 * 这句话到底做了什么事情呢？
 * 1.javac编译.java源文件形成.class字节码文件;
 * 2.new SubClass()对象时，先检查有没有父类，有父类，类加载器(ClassLoader)先将父类的Class文件读入内存，创建一个java.lang.Class对象，然后加载子类，类加载器将子类的Class文件读入内存，创建一个java.lang.Class对象;
 * 3.先初始化父类的静态属性，再初始化父类的静态代码块；
 * 4.再初始化子类的静态属性，再初始化子类的静态代码；
 * 5.在堆内存中分配内存空间，分配内存地址，此时是因为父类的特有属性才在堆内存中为父类对象分配空间。
 * 6.初始化父类的特有属性。
 * 7.初始化父类的构造代码块。
 * 8.初始化父类对象相应的构造方法。
 * 9.在堆内存中分配内存空间，分配内存地址，此时是因为子类的特有属性才在堆内存中为子类对象分配空间的。
 * 10.初始化子类的特有属性。
 * 11.初始化子类的构造代码块。
 * 12.初始化子类相应的构造方法。
 * 13.将子类的内存地址赋值给栈中的引用对象。
 *
 * 创建String对象的方式的讨论——引号内包含文本。
 *
 * 这种方式是String特有的，并且它与new的方式存在很大区别。
 * String str="abc";
 * 毫无疑问，这行代码创建了一个String对象。
 * String a="abc";  String b="abc";   那这里呢？
 * 答案还是一个。
 * String a="ab"+"cd";   再看看这里呢？
 * 答案是三个。
 * 只有使用引号包含文本的方式创建的String对象之间使用“+”连接产生的新对象才会被加入字符串池中。对于所有包含new方式新建对象（包括null）的“+”连接表达式，它所产生的新对象都不会被加入字符串池中
 *
 * 什么情况会引起栈满[https://www.cnblogs.com/Javajishuzhai/p/11335309.html]
 * 3）栈溢出： java.lang.StackOverflowError : Thread Stack space
 * 栈溢出了，JVM依然是采用栈式的虚拟机，这个和C和Pascal都是一样的。函数的调用过程都体现在堆栈和退栈上了。调用构造函数的 “层”太多了，以致于把栈区溢出了。 通常来讲，一般栈区远远小于堆区的，因为函数调用过程往往不会多于上千层，而即便每个函数调用需要 1K的空间（这个大约相当于在一个C函数内声明了256个int类型的变量），那么栈区也不过是需要1MB的空间。通常栈的大小是1-2MB的。通俗一点讲就是单线程的程序需要的内存太大了。 通常递归也不要递归的层次过多，很容易溢出。
 * 解决方法 ：1：修改程序。2：通过 -Xss: 来设置每个线程的Stack大小即
 *
 * 什么是自旋锁
 * synchronized 如何实现锁定一个对象
 * 实现原理： JVM 是通过进入、退出 对象监视器(Monitor) 来实现对方法、同步块的同步的，而对象监视器的本质依赖于底层操作系统的 互斥锁(Mutex Lock) 实现。
 * 具体实现是在编译之后在同步方法调用前加入一个monitor.enter指令，在退出方法和异常处插入monitor.exit的指令。
 * 对于没有获取到锁的线程将会阻塞到方法入口处，直到获取锁的线程monitor.exit之后才能尝试继续获取锁。
 *
 * synchronized的实现原理
 * 使用monitorenter和monitorexit指令实现的：
 * monitorenter指令是在编译后插入到同步代码块的开始位置，而monitorexit是插入到方法结束处和异常处
 * 每个monitorenter必须有对应的monitorexit与之配对
 * 任何对象都有一个monitor与之关联，当且一个monitor被持有后，它将处于锁定状态
 *
 * volatile 如何实现的
 * 如果把加入volatile关键字的代码和未加入volatile关键字的代码都生成汇编代码，会发现加入volatile关键字的代码会多出一个lock前缀指令。
 * lock前缀指令实际相当于一个内存屏障，内存屏障提供了以下功能：
 * 1 . 重排序时不能把后面的指令重排序到内存屏障之前的位置
 * 2 . 使得本CPU的Cache写入内存
 * 3 . 写入动作也会引起别的CPU或者别的内核无效化其Cache，相当于让新写入的值对别的线程可见。
 *
 * 三.volatile关键字的实现原理
 * 在java代码编译成字节码时会在volatile修饰的共享变量进行写操作的时候会多出Lock前缀的指令。
 * 我们知道为了提高处理速度，CPU不直接和内存进行通信，而是先将系统内存的数据读到内部缓存（L1，L2或其他）后再进行操作，但操作完不知道何时会写回内存。如果对声明了volatile的变量进行写操作，JVM就会向CPU发送一条Lock前缀的指令，将这个变量所在缓存行的数据写回到系统内存。但是，就算写回到内存，如果其他处理器缓存的值还是旧的，再执行计算操作就会有问题。所以，在多处理器下，为了保证各个CPU的缓存是一致的，就会实现缓存一致性协议，每个CPU通过嗅探在总线上传播的数据来检查自己缓存的值是不是过期了，当处理器发现自己缓存行对应的内存地址被修改，就会将当前CPU的缓存行设置成无效状态，当CPU对这个数据进行修改操作的时候，会重新从系统内存中把数据读到处理器缓存里
 * Lock前缀的指令会引起CPU缓存写回内存；
 * 一个CPU的缓存回写到内存会导致其他处理器的缓存失效；
 * 当CPU发现本地缓存失效后，就会从内存中重读该变量数据，即可以获取当前最新值。
 * 这样针对volatile变量通过这样的机制就使得每个线程都能获得该变量的最新值
 *
 * 一.happens-before原则
 * 同一个线程中的，前面的操作 happens-before 后续的操作。（即单线程内按代码顺序执行。但是，在不影响在单线程环境执行结果的前提下，编译器和处理器可以进行重排序，这是合法的。换句话说，这一是规则无法保证编译重排和指令重排）。
 *
 * Volatile关键字主要用于保证内存可见性和顺序性：
 * 1.volatile修饰的变量可以保证一个线程对该变量的写happens-before 一个线程对该变量的读
 * 2.Volatile可以用来修饰long和double类型的变量使其以原子方式执行
 * 3.Volatile在双重检查加锁的单例模式中的应用，可以防止重排序
 *
 *
 * 数据库索引的高度，为什么是这么高？
 * 在InnoDB里，每个页默认16KB，假设索引的是8B的long型数据，每个key后有个页号4B，还有6B的其他数据（参考《MySQL技术内幕：InnoDB存储引擎》P193的页面数据），那么每个页的扇出系数为16KB/(8B+4B+6B)≈1000，即每个页可以索引1000个key。在高度h=3时，s=1000^3=10亿！！也就是说，InnoDB通过三次索引页的I/O，即可索引10亿的key。通常来说，索引树的高度在2~4。当然，这也跟要索引字段的数据类型有关，如果是int或short，索引效率更好，而如果是varchar(100)，那扇出系数就低了，索引效率自然要低些。所以我们在索引字段时，字段的类型越简单效率越好。
 *
 * 表A有字段id,a,b,c,d。id是主键，a,b,c是联合索引
 * select c from A where a=1 and b=2
 * select d from A where a=1 and b=2
 * select d from A where b=2 and c=3
 *
 * 说到辅助索引，我们还可以延伸出另一种特别的索引，就是覆盖索引。
 * 上面说了，聚簇索引中访问数据要经过二次查找，就是先找到辅助键的叶子结点，得到主键对应的结点后再用主键索引查询数据，这样还是比较慢的，其实，如果我们所需的字段第一次查找就能获取到的话，就不用再二次查找主键了，也就是不用“回表”。
 * 就还是上面那张表有三个字段id，name，company的表来说，我给name加了索引，在查询数据的时候，我就这么写语句：
 * select name from user where name like '张%';
 * 因为我们的语句走了索引，并且返回的字段在叶子结点都存在，查询的时候就不会回表了，多好啊~~
 * 所以，如果所需的字段刚好是索引列的话，尽量用这种查询方式，不要用select *这种语句。
 *
 * 可以把每个类加载都想成一个大懒汉，每次让他办事时他都让爸爸代办。没想到爸爸也是个大懒汉，于是爸爸也让他的爸爸代办。这是到了爷爷那里，爷爷也很懒，但是他没有爸爸了，于是只能一边抱怨一边干，然后发现自己做不了，又骂骂咧咧的把活儿交给了自己的儿子，然后爸爸开始干活，发现自己也不能完成这个任务，于是他也是骂骂咧咧的把活交给了儿子，儿子挨了一顿骂，然后开始干活，经过了1小时的苦干，这个活儿终于完事了。
 */
public class Sub {
}
